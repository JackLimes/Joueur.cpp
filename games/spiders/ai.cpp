// Generated by Creer at 03:31PM on April 06, 2016 UTC, git hash:
// 'e7ec4e35c89d7556b9e07d4331ac34052ac011bd'
// This is where you build your AI for the Spiders game.

#include "ai.h"

#include <iostream>
using std::cout;
using std::endl;

template <typename T>
T randomElement(std::vector<T> v);

/// <summary>
/// This returns your AI's name to the game server. Just replace the string.
/// </summary>
/// <returns>string of you AI's name.</returns>
std::string Spiders::AI::getName() {
  return "Spiders C++ Player";  // REPLACE THIS WITH YOUR TEAM NAME!
}

/// <summary>
/// This is automatically called when the game first starts, once the Game
/// object and all GameObjects have been initialized, but before any players do
/// anything.
/// </summary>
void Spiders::AI::start() { srand(time(NULL)); }

/// <summary>
/// This is automatically called every time the game (or anything in it)
/// updates.
/// </summary>
void Spiders::AI::gameUpdated() {}

/// <summary>
/// This is automatically called when the game ends.
/// </summary>
/// <param name="won">true if your player won, false otherwise</param>
/// <param name="reason">a string explaining why you won or lost</param>
void Spiders::AI::ended(bool won, std::string reason) {}

/// <summary>
/// This is called every time it is this AI.player's turn.
/// </summary>
/// <returns>Represents if you want to end your turn. True means end your turn,
/// False means to keep your turn going and re-call this function.</returns>
bool Spiders::AI::runTurn() {
  // This is ShellAI, it is very simple, and demonstrates how to use all the
  // game objects in Spiders

  // get a random spider to try to do things with
  Spider* spider = randomElement(player->spiders);

  // if that spider is a Spitter
  if (spider->gameObjectName == "Spitter") {
    // this is how you cast pointers in C++
    Spitter* spitter = dynamic_cast<Spitter*>(spider);
    Nest* enemysNest = player->otherPlayer->broodMother->nest;

    // loop through to check to make sure there is not already a Web to the
    // enemy's nest. note that C++11 constructs are available, but not required.
    Web* existingWeb = nullptr;
    for (auto& web : enemysNest->webs) {
      if (web->nestA == spitter->nest && web->nestB == spitter->nest) {
        existingWeb = web;
        break;
      }
    }

    if (existingWeb != nullptr)  // we can't spit to that nest, so move to it
      spitter->move(existingWeb);
    else
      spitter->spit(enemysNest);

  } else if (spider->gameObjectName == "Cutter") {
    // this is how you use auto
    auto cutter = dynamic_cast<Cutter*>(spider);
    if (cutter->nest->webs.size() > 0) {  // cut one of them
      Web* targetWeb = randomElement(cutter->nest->webs);
      cutter->cut(targetWeb);
    } else if (cutter->nest->spiders.size() > 1) {
      // get a random other spider to see if we can attack
      Spider* otherSpider = randomElement(cutter->nest->spiders);

      // Spiderling::attack(Spiderling*) needs a Spiderling*. We have a Spider*.
      // We can use dynamic_cast to attempt to cast our Spider* to a
      // Spiderling*. It might not be a Spiderling though, because it might be
      // the "friendly" BroodMother. If you ask dynamic_cast to cast something,
      // and it can't (because the broodmother isn't a Spiderling, for example),
      // then it will return nullptr.
      Spiderling* targetSpider = dynamic_cast<Spiderling*>(otherSpider);
      if (otherSpider != nullptr) {  // must not be broodmother!
        if (otherSpider->owner != cutter->owner) {
          cutter->attack(targetSpider);
        }
      }
    }
  } else if (spider->gameObjectName == "Weaver") {
    auto weaver = dynamic_cast<Weaver*>(spider);
    if (weaver->nest->webs.size() > 0) {  // weave a web
      // 50% of the time do a strengthening weave,
      // the other 50% of the time weaken
      Web* targetWeb = randomElement(weaver->nest->webs);

      if (rand() % 2 == 1) {
        weaver->strengthen(targetWeb);
      } else {
        weaver->weaken(targetWeb);
      }
    } else if (weaver->nest->spiders.size() > 1) {  // try to attack one of them

      // pick a random other spider
      Spider* otherSpider = randomElement(spider->nest->spiders);
      Spiderling* targetSpider = dynamic_cast<Spiderling*>(otherSpider);
      if (targetSpider != nullptr) {  // must not be broodmother!
        if (targetSpider->owner != weaver->owner) {
          weaver->attack(targetSpider);
        }
      }
    }
  } else if (spider->gameObjectName == "BroodMother") {
    auto broodMother = dynamic_cast<BroodMother*>(spider);

    // try to consume a Spiderling
    if (broodMother->nest->spiders.size() > 1) {  // there is another spider

      // pick a random other spider
      Spider* otherSpider = randomElement(spider->nest->spiders);
      Spiderling* spiderling = dynamic_cast<Spiderling*>(otherSpider);

      // as above, use the nullptr return to ensure we really have a Spiderling
      if (spiderling != nullptr) {  // must not be broodMother (myself)!
        broodMother->consume(spiderling);
      }
    }

    // try to spawn a Spiderling
    if (broodMother->eggs > 0) {
      // this is the syntax for initializer lists
      // (which is different from initialization lists. that's constructors)
      std::vector<std::string> spiderlingTypes{"Cutter", "Weaver", "Spitter"};
      broodMother->spawn(randomElement(spiderlingTypes));
    }
  }
  return true;
}

// utility function, can't let the dynamic language guys have all the fun
template <typename T>
T randomElement(std::vector<T> v) {
  T nullResult;
  if (v.size() == 0) return nullResult;
  return v[rand() % v.size()];
}
